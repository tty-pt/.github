name: 'package-fpm'
description: 'Build and sign packages using fpm with native package manager for setup'
author: 'tty-pt'

inputs:
  name:
    description: 'Package name'
    required: true
  format:
    description: 'PM Format'
    required: true
  ext:
    description: 'Output file extension for this format'
    required: false
    default: ''
  deps:
    description: 'Comma-separated list of runtime dependencies'
    required: false
  gpg_key:
    description: 'ASCII-armored private GPG key to sign the package'
    required: false
    default: ''
  gpg_keyid:
    description: 'Key ID or fingerprint for signing'
    required: false
    default: ''
  gpg_pass:
    description: 'Passphrase for the GPG key (optional)'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - uses: actions/checkout@v4

    - name: Install prerequisites (native)
      run: |
        if command -v apk >/dev/null; then
          apk add --no-cache ruby ruby-dev build-base gnupg git
          gem install fpm
        elif command -v apt-get >/dev/null; then
          sudo apt-get update -y
          sudo apt-get install -y ruby ruby-dev build-essential gnupg git
          sudo gem install fpm
        elif command -v dnf >/dev/null; then
          dnf install -y ruby ruby-devel make gcc gcc-c++ gnupg git rpm-build rpm-sign
          gem install fpm
        elif command -v pacman >/dev/null; then
          pacman -Sy --noconfirm ruby ruby-erb base-devel gnupg git
          gem install --no-document fpm -v 1.17.0 --bindir /usr/bin
        else
          echo "Unsupported base image" >&2; exit 1
        fi
      shell: sh

    - name: Import GPG key (if provided)
      if: inputs.gpg_key != ''
      run: |
        mkdir -p ~/.gnupg
        echo "${{ inputs.gpg_key }}" | gpg --batch --yes --import
      shell: sh

    - name: Fetch include.mk from tty-pt/mk
      run: |
        git clone --branch main https://github.com/tty-pt/mk ../mk
      shell: sh

    - name: Build and stage project
      run: |
        make
        make DESTDIR=$PWD/stage PREFIX=/usr install
      shell: sh

    - name: Create package with fpm
      run: |
        NAME="${{ inputs.name }}"
        VER="${GITHUB_REF_NAME#v}"
        FMT="${{ inputs.format }}"
        DEPS="${{ inputs.deps }}"
        mkdir -p dist

        SIGN_ARGS=""
        case "$FMT" in
          deb) SIGN_ARGS="--deb-sign ${{ inputs.gpg_keyid }}" ;;
          rpm)
            mkdir -p ~/.gnupg
            chmod 700 ~/.gnupg
            echo "allow-loopback-pinentry" > ~/.gnupg/gpg-agent.conf
            echo "use-agent" > ~/.gnupg/gpg.conf
            gpgconf --kill gpg-agent
            gpgconf --launch gpg-agent

            echo "%_signature gpg" > ~/.rpmmacros
            echo "%_gpg_name ${{ inputs.gpg_keyid }}" >> ~/.rpmmacros
            echo "%_gpg_path $HOME/.gnupg" >> ~/.rpmmacros
            echo "%_gpgbin $(command -v gpg)" >> ~/.rpmmacros
            SIGN_ARGS="--rpm-sign"
            ;;
        esac

        fpm -s dir -t "$FMT" \
            -n "$NAME" -v "$VER" \
            --license MIT \
            --url "https://github.com/${{ github.repository }}" \
            --maintainer "tty.pt repo <repo@tty.pt>" \
            $( [ -n "$DEPS" ] && for d in $(echo "$DEPS" | tr ',' ' '); do echo -n "--depends $d "; done ) \
            $SIGN_ARGS \
            -C stage usr

        # Handle Alpine signing separately
        if [ "$FMT" = "apk" ] && [ -f ~/.abuild/${NAME}.rsa ]; then
          apk add --no-cache abuild >/dev/null 2>&1 || true
          abuild-sign -k "$HOME/.abuild/${NAME}.rsa" dist/*.apk
        fi

        # Move result using the declared extension
        EXT="${{ inputs.ext }}"
        test ! -z "$EXT" || EXT="$FMT"
        mv *."$EXT" dist/
      shell: sh

    - uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.name }}-${{ inputs.format }}
        path: dist/*.${{ inputs.ext || inputs.format }}
