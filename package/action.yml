name: 'package'
description: 'Compile C projects with include.mk and package for Linux (deb,rpm,apk), Windows (zip), OpenBSD (tar.gz) and source tarball'
author: 'tty-pt'

inputs:
  name:
    description: 'Package name'
    required: true
  version:
    description: 'Package version (defaults to tag name)'
    required: false
  deps:
    description: 'Comma-separated list of package dependencies'
    required: false
  prefix:
    description: 'Install prefix (default /usr/local)'
    default: '/usr/local'

runs:
  using: 'composite'
  steps:
    - name: Checkout project
      uses: actions/checkout@v4

    - name: Fetch include.mk from tty-pt/mk
      run: |
        git clone --branch main https://github.com/tty-pt/mk ../mk
      shell: bash

    - name: Resolve version
      id: vars
      run: |
        if [ -n "${{ inputs.version }}" ]; then
          echo "VERSION=${{ inputs.version }}" >> $GITHUB_ENV
        else
          echo "VERSION=${GITHUB_REF_NAME#v}" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Install packaging tools
      if: runner.os == 'Linux'
      run: |
        echo "deb [trusted=yes] http://tty.pt/apt stable main" | sudo tee /etc/apt/sources.list.d/ttypt.list
        sudo apt-get update
        sudo rm -f /var/lib/man-db/auto-update
        if [ -n "${{ inputs.deps }}" ]; then
          sudo apt-get install -y $(echo "${{ inputs.deps }}" | tr ',' ' ')
        fi

        sudo apt-get install -y ruby ruby-dev build-essential

        # pacman support
        sudo apt-get install -y libarchive-tools

        # Install other packaging tools
        sudo apt-get install -y rpm alien

        # Install fpm gem
        sudo gem install --no-document fpm

        echo "Packaging tools installed:"
        which fpm
        bsdtar --version || echo "bsdtar not available (non-fatal)"
        rpm --version || echo "rpm not available (non-fatal)"
      shell: bash

    - name: Build
      run: make
      shell: bash

    - name: Install to staging
      run: make DESTDIR=$PWD/stage PREFIX=${{ inputs.prefix }} install
      shell: bash

    - name: Package source tarball
      if: runner.os == 'Linux'
      run: |
        mkdir -p dist
        tar czf dist/${{ inputs.name }}-${{ env.VERSION }}-src.tar.gz \
          --exclude=.git \
          --exclude=dist \
          --exclude=stage \
          .
      shell: bash

    - name: Install packaging tools (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y ruby ruby-dev build-essential
        sudo gem install --no-document fpm
      shell: bash

    - name: Package Linux (DEB, RPM, APK, PACMAN)
      if: runner.os == 'Linux'
      run: |
        mkdir -p dist
        DEPENDS_OPTS=""
        if [ -n "${{ inputs.deps }}" ]; then
          for dep in $(echo "${{ inputs.deps }}" | tr ',' ' '); do
            DEPENDS_OPTS="$DEPENDS_OPTS --depends $dep"
          done
        fi

        LICENSE="MIT"
        VENDOR="${{ github.repository_owner }}"
        MAINTAINER="${{ github.repository_owner }} <noreply@github.com>"
        HOMEPAGE="https://github.com/${{ github.repository }}"
        DESC="${{ github.event.repository.description }}"
        if [ -z "$DESC" ]; then
          DESC="C library ${{ inputs.name }}"
        fi

        # Detect architecture from built binaries
        ARCH="amd64"
        # Look for binaries in stage directory to determine actual architecture
        if find stage -type f -executable | grep -q .; then
          # We have binaries, check their architecture
          BINARY=$(find stage -type f -executable | head -1)
          if file "$BINARY" | grep -q "ARM"; then
            ARCH="arm64"
          elif file "$BINARY" | grep -q "x86-64"; then
            ARCH="x86_64"
          elif file "$BINARY" | grep -q "80386"; then
            ARCH="x86"
          fi
        else
          # No binaries found, this might be a header-only or architecture-independent library
          echo "No binaries found, this appears to be an architecture-independent package"
        fi

        echo "Detected architecture: $ARCH"

        # Build DEB package
        fpm -s dir -t deb -n ${{ inputs.name }} -v ${{ env.VERSION }} \
            -C stage \
            --license "$LICENSE" \
            --vendor "$VENDOR" \
            --maintainer "$MAINTAINER" \
            --url "$HOMEPAGE" \
            --description "$DESC" \
            --category "devel" \
            --architecture "$ARCH" \
            $DEPENDS_OPTS

        # Build RPM package
        fpm -s dir -t rpm -n ${{ inputs.name }} -v ${{ env.VERSION }} \
            -C stage \
            --license "$LICENSE" \
            --vendor "$VENDOR" \
            --maintainer "$MAINTAINER" \
            --url "$HOMEPAGE" \
            --description "$DESC" \
            --category "devel" \
            --architecture "$ARCH" \
            $DEPENDS_OPTS

        # Build APK package
        fpm -s dir -t apk -n ${{ inputs.name }} -v ${{ env.VERSION }} \
            -C stage \
            --license "$LICENSE" \
            --vendor "$VENDOR" \
            --maintainer "$MAINTAINER" \
            --url "$HOMEPAGE" \
            --description "$DESC" \
            --category "devel" \
            --architecture "$ARCH" \
            $DEPENDS_OPTS

        # Build Pacman package
        fpm -s dir -t pacman -n ${{ inputs.name }} -v ${{ env.VERSION }} \
            -C stage \
            --license "$LICENSE" \
            --vendor "$VENDOR" \
            --maintainer "$MAINTAINER" \
            --url "$HOMEPAGE" \
            --description "$DESC" \
            --category "devel" \
            --architecture "$ARCH" \
            $DEPENDS_OPTS

        # Move all packages to dist directory
        mv *.deb *.rpm *.apk *.pkg.tar.* dist/ 2>/dev/null || true

        echo "Packages built:"
        ls -la dist/
        echo "Package architectures:"
        for pkg in dist/*; do
          echo "$(basename $pkg): $(file $pkg | cut -d: -f2-)"
        done
      shell: bash

    - name: Package Windows
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        mkdir dist
        Compress-Archive -Path stage\* -DestinationPath dist\${{ inputs.name }}-${{ env.VERSION }}-win.zip

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.name }}-${{ runner.os }}
        path: dist/*
