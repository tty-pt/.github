name: 'package'
description: 'Compile C projects with include.mk and package for multiple platforms'
author: 'tty-pt'

inputs:
  name:
    description: 'Package name'
    required: true
  version:
    description: 'Package version (defaults to tag name)'
    required: false
  deps:
    description: 'Comma-separated list of package dependencies'
    required: false
  prefix:
    description: 'Install prefix (default /usr/local)'
    default: '/usr/local'
  publish_to:
    description: "Package managers to publish to"
    required: false
    default: "apt,apk,pacman,macos"
    type: string

runs:
  using: 'composite'
  steps:
    - name: Checkout project
      uses: actions/checkout@v4

    - name: Fetch include.mk from tty-pt/mk
      run: |
        git clone --branch main https://github.com/tty-pt/mk ../mk
      shell: bash

    - name: Resolve version
      id: vars
      run: |
        if [ -n "${{ inputs.version }}" ]; then
          echo "VERSION=${{ inputs.version }}" >> $GITHUB_ENV
        else
          echo "VERSION=${GITHUB_REF_NAME#v}" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Install build deps (Linux)
      if: runner.os == 'Linux'
      run: |
        echo "deb [trusted=yes] http://tty.pt/apt stable main" | sudo tee /etc/apt/sources.list.d/ttypt.list
        sudo apt-get update
        sudo rm -f /var/lib/man-db/auto-update
        if [ -n "${{ inputs.deps }}" ]; then
          sudo apt-get install -y $(echo "${{ inputs.deps }}" | tr ',' ' ')
        fi
      shell: bash

    - name: Install build deps (macOS)
      if: runner.os == 'macOS'
      run: |
        # Install common build tools on macOS
        brew update
        if [ -n "${{ inputs.deps }}" ]; then
          for dep in $(echo "${{ inputs.deps }}" | tr ',' ' '); do
            brew install "$dep" || echo "Dependency $dep not found in Homebrew"
          done
        fi
      shell: bash

    - name: Build
      run: make
      shell: bash

    - name: Install to staging
      run: |
        make DESTDIR=$PWD/stage PREFIX=${{ inputs.prefix }} install
      shell: bash

    - name: Package source tarball
      if: runner.os == 'Linux'
      run: |
        mkdir -p dist
        tar czf dist/${{ inputs.name }}-${{ env.VERSION }}-src.tar.gz \
          --exclude=.git \
          --exclude=dist \
          --exclude=stage \
          .
      shell: bash

    - name: Install packaging tools (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo rm -f /var/lib/man-db/auto-update
        sudo apt-get install -y ruby ruby-dev build-essential libarchive-tools rpm
        sudo gem install --no-document fpm
      shell: bash

    - name: Package Linux
      if: runner.os == 'Linux'
      run: |
        # Create separate directories for each package type
        mkdir -p dist-linux/deb dist-linux/apk dist-linux/pacman dist-linux/rpm
        
        # Common FPM options
        DEPENDS_OPTS=""
        if [ -n "${{ inputs.deps }}" ]; then
          for dep in $(echo "${{ inputs.deps }}" | tr ',' ' '); do
            DEPENDS_OPTS="$DEPENDS_OPTS --depends $dep"
          done
        fi

        LICENSE="MIT"
        VENDOR="${{ github.repository_owner }}"
        MAINTAINER="${{ github.repository_owner }} <noreply@github.com>"
        HOMEPAGE="https://github.com/${{ github.repository }}"
        DESC="${{ github.event.repository.description }}"
        if [ -z "$DESC" ]; then
          DESC="C library ${{ inputs.name }}"
        fi

        # Detect architecture
        ARCH="amd64"
        if find stage -type f -executable | grep -q .; then
          BINARY=$(find stage -type f -executable | head -1)
          if file "$BINARY" | grep -q "ARM"; then
            ARCH="arm64"
          elif file "$BINARY" | grep -q "x86-64"; then
            ARCH="x86_64"
          elif file "$BINARY" | grep -q "80386"; then
            ARCH="x86"
          fi
        fi

        echo "Detected architecture: $ARCH"

        # Build DEB to deb/ directory
        if [[ " ${{ inputs.publish_to }} " == *"apt"* ]]; then
          fpm -s dir -t deb -n ${{ inputs.name }} -v ${{ env.VERSION }} \
              -C stage \
              --license "$LICENSE" \
              --vendor "$VENDOR" \
              --maintainer "$MAINTAINER" \
              --url "$HOMEPAGE" \
              --description "$DESC" \
              --category "devel" \
              --architecture "$ARCH" \
              $DEPENDS_OPTS
          mv *.deb dist-linux/deb/ 2>/dev/null || true
        fi

        # Build APK to apk/ directory
        if [[ " ${{ inputs.publish_to }} " == *"apk"* ]]; then
          fpm -s dir -t apk -n ${{ inputs.name }} -v ${{ env.VERSION }} \
              -C stage \
              --license "$LICENSE" \
              --vendor "$VENDOR" \
              --maintainer "$MAINTAINER" \
              --url "$HOMEPAGE" \
              --description "$DESC" \
              --category "devel" \
              --architecture "$ARCH" \
              $DEPENDS_OPTS
          mv *.apk dist-linux/apk/ 2>/dev/null || true
        fi

        # Build Pacman to pacman/ directory
        if [[ " ${{ inputs.publish_to }} " == *"pacman"* ]]; then
          fpm -s dir -t pacman -n ${{ inputs.name }} -v ${{ env.VERSION }} \
              -C stage \
              --license "$LICENSE" \
              --vendor "$VENDOR" \
              --maintainer "$MAINTAINER" \
              --url "$HOMEPAGE" \
              --description "$DESC" \
              --category "devel" \
              --architecture "$ARCH" \
              $DEPENDS_OPTS || echo "Pacman package build failed"
          mv *.pkg.tar.* dist-linux/pacman/ 2>/dev/null || true
        fi

        # Build RPM to rpm/ directory
        if [[ " ${{ inputs.publish_to }} " == *"rpm"* ]]; then
          fpm -s dir -t rpm -n ${{ inputs.name }} -v ${{ env.VERSION }} \
              -C stage \
              --license "$LICENSE" \
              --vendor "$VENDOR" \
              --maintainer "$MAINTAINER" \
              --url "$HOMEPAGE" \
              --description "$DESC" \
              --category "devel" \
              --architecture "$ARCH" \
              $DEPENDS_OPTS
          mv *.rpm dist-linux/rpm/ 2>/dev/null || true
        fi
        
        echo "Linux package distribution:"
        find dist-linux -type f | sort
      shell: bash

    - name: Package macOS
      if: runner.os == 'macOS'
      run: |
        mkdir -p dist-macos
        ARCH=$(uname -m)
        
        # Create architecture-specific tarball
        tar czf "dist-macos/${{ inputs.name }}-${{ env.VERSION }}-macos-$ARCH.tar.gz" -C stage .
        
        # Optional: Simple component package
        pkgbuild --root stage \
                 --identifier "com.${{ github.repository_owner }}.${{ inputs.name }}" \
                 --version "${{ env.VERSION }}" \
                 --install-location "${{ inputs.prefix }}" \
                 "dist-macos/${{ inputs.name }}-${{ env.VERSION }}-$ARCH.pkg"
        
        echo "macOS packages created:"
        ls -la dist-macos/
      shell: bash

    - name: Package Windows
      if: runner.os == 'Windows'
      run: |
        mkdir dist-windows
        # Add architecture detection for Windows
        $arch = if ($env:PROCESSOR_ARCHITECTURE -eq "ARM64") { "arm64" } else { "x64" }
        Compress-Archive -Path stage\* -DestinationPath "dist-windows\${{ inputs.name }}-${{ env.VERSION }}-win-$arch.zip"
        
        # Create source tarball for Windows build
        tar czf "dist-windows/${{ inputs.name }}-${{ env.VERSION }}-src.tar.gz" \
          --exclude=.git \
          --exclude=dist-* \
          --exclude=stage \
          .
      shell: pwsh

    - name: Capture build info
      run: |
        echo "COMMIT_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV
        echo "COMMIT_SHORT=$(git rev-parse --short HEAD)" >> $GITHUB_ENV
        echo "BUILD_DATE=$(date -u +%Y-%m-%d)" >> $GITHUB_ENV

        # Create build info file for this platform
        cat > BUILD_INFO << EOF
        Package: ${{ inputs.name }}
        Version: ${{ env.VERSION }}
        Commit: $(git rev-parse HEAD)
        CommitShort: $(git rev-parse --short HEAD)
        BuildDate: $(date -u +%Y-%m-%d)
        BuildOS: ${{ runner.os }}
        Architecture: $(uname -m)
        EOF
      shell: bash

    - name: Generate checksums for each platform
      run: |
        # Generate checksums for the appropriate dist directory
        if [ "${{ runner.os }}" = "Linux" ]; then
          cd dist-linux
        elif [ "${{ runner.os }}" = "macOS" ]; then
          cd dist-macos
        elif [ "${{ runner.os }}" = "Windows" ]; then
          cd dist-windows
        fi
        
        # Include BUILD_INFO in checksums
        cp ../BUILD_INFO .
        find . -type f -name "*" | xargs shasum -a 256 > SHA256SUMS
        echo "Generated checksums:"
        cat SHA256SUMS
      shell: bash

    - name: Capture build info
      run: |
        echo "COMMIT_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV
        echo "COMMIT_SHORT=$(git rev-parse --short HEAD)" >> $GITHUB_ENV
        echo "BUILD_DATE=$(date -u +%Y-%m-%d)" >> $GITHUB_ENV

        # Create build info file
        cat > BUILD_INFO << EOF
        Package: ${{ inputs.name }}
        Version: ${{ env.VERSION }}
        Commit: $(git rev-parse HEAD)
        CommitShort: $(git rev-parse --short HEAD)
        BuildDate: $(date -u +%Y-%m-%d)
        BuildOS: ${{ runner.os }}
        EOF
      shell: bash

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.name }}-${{ runner.os }}
        path: |
          ${{ runner.os == 'Linux' && 'dist-linux/*' || '' }}
          ${{ runner.os == 'macOS' && 'dist-macos/*' || '' }}
          ${{ runner.os == 'Windows' && 'dist-windows/*' || '' }}
