name: 'package'
description: 'Compile C projects with include.mk and package for multiple platforms'
author: 'tty-pt'

inputs:
  name:
    description: 'Package name'
    required: true
  version:
    description: 'Package version (defaults to tag name)'
    required: false
  deps:
    description: 'Comma-separated list of package dependencies'
    required: false
  prefix:
    description: 'Install prefix (default /usr/local)'
    default: '/usr/local'

runs:
  using: 'composite'
  steps:
    - name: Checkout project
      uses: actions/checkout@v4

    - name: Fetch include.mk from tty-pt/mk
      run: |
        git clone --branch main https://github.com/tty-pt/mk ../mk
      shell: bash

    - name: Resolve version
      id: vars
      run: |
        if [ -n "${{ inputs.version }}" ]; then
          echo "VERSION=${{ inputs.version }}" >> $GITHUB_ENV
        else
          echo "VERSION=${GITHUB_REF_NAME#v}" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Install build deps (Linux)
      if: runner.os == 'Linux'
      run: |
        echo "deb [trusted=yes] http://tty.pt/apt stable main" | sudo tee /etc/apt/sources.list.d/ttypt.list
        sudo apt-get update
        sudo rm -f /var/lib/man-db/auto-update
        if [ -n "${{ inputs.deps }}" ]; then
          sudo apt-get install -y $(echo "${{ inputs.deps }}" | tr ',' ' ')
        fi
      shell: bash

    - name: Install build deps (macOS)
      if: runner.os == 'macOS'
      run: |
        # Install common build tools on macOS
        brew update
        if [ -n "${{ inputs.deps }}" ]; then
          for dep in $(echo "${{ inputs.deps }}" | tr ',' ' '); do
            brew install "$dep" || echo "Dependency $dep not found in Homebrew"
          done
        fi
      shell: bash

    - name: Build
      run: make
      shell: bash

    - name: Install to staging
      run: |
        make DESTDIR=$PWD/stage PREFIX=${{ inputs.prefix }} install
      shell: bash

    - name: Package source tarball
      if: runner.os == 'Linux'
      run: |
        mkdir -p dist
        tar czf dist/${{ inputs.name }}-${{ env.VERSION }}-src.tar.gz \
          --exclude=.git \
          --exclude=dist \
          --exclude=stage \
          .
      shell: bash

    - name: Install packaging tools (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo rm -f /var/lib/man-db/auto-update
        sudo apt-get install -y ruby ruby-dev build-essential libarchive-tools rpm
        sudo gem install --no-document fpm
      shell: bash

    - name: Package Linux
      if: runner.os == 'Linux'
      run: |
        mkdir -p dist
        DEPENDS_OPTS=""
        if [ -n "${{ inputs.deps }}" ]; then
          for dep in $(echo "${{ inputs.deps }}" | tr ',' ' '); do
            DEPENDS_OPTS="$DEPENDS_OPTS --depends $dep"
          done
        fi

        LICENSE="MIT"
        VENDOR="${{ github.repository_owner }}"
        MAINTAINER="${{ github.repository_owner }} <noreply@github.com>"
        HOMEPAGE="https://github.com/${{ github.repository }}"
        DESC="${{ github.event.repository.description }}"
        if [ -z "$DESC" ]; then
          DESC="C library ${{ inputs.name }}"
        fi

        # Detect architecture from built binaries
        ARCH="amd64"
        # Look for binaries in stage directory to determine actual architecture
        if find stage -type f -executable | grep -q .; then
          # We have binaries, check their architecture
          BINARY=$(find stage -type f -executable | head -1)
          if file "$BINARY" | grep -q "ARM"; then
            ARCH="arm64"
          elif file "$BINARY" | grep -q "x86-64"; then
            ARCH="x86_64"
          elif file "$BINARY" | grep -q "80386"; then
            ARCH="x86"
          fi
        else
          # No binaries found, this might be a header-only or architecture-independent library
          echo "No binaries found, this appears to be an architecture-independent package"
        fi

        echo "Detected architecture: $ARCH"

        # Build packages
        fpm -s dir -t deb -n ${{ inputs.name }} -v ${{ env.VERSION }} \
            -C stage \
            --license "$LICENSE" \
            --vendor "$VENDOR" \
            --maintainer "$MAINTAINER" \
            --url "$HOMEPAGE" \
            --description "$DESC" \
            --category "devel" \
            --architecture "$ARCH" \
            $DEPENDS_OPTS

        # Build RPM package
        fpm -s dir -t rpm -n ${{ inputs.name }} -v ${{ env.VERSION }} \
            -C stage \
            --license "$LICENSE" \
            --vendor "$VENDOR" \
            --maintainer "$MAINTAINER" \
            --url "$HOMEPAGE" \
            --description "$DESC" \
            --category "devel" \
            --architecture "$ARCH" \
            $DEPENDS_OPTS

        # Build APK package
        fpm -s dir -t apk -n ${{ inputs.name }} -v ${{ env.VERSION }} \
            -C stage \
            --license "$LICENSE" \
            --vendor "$VENDOR" \
            --maintainer "$MAINTAINER" \
            --url "$HOMEPAGE" \
            --description "$DESC" \
            --category "devel" \
            --architecture "$ARCH" \
            $DEPENDS_OPTS

        # Build Pacman package
        fpm -s dir -t pacman -n ${{ inputs.name }} -v ${{ env.VERSION }} \
            -C stage \
            --license "$LICENSE" \
            --vendor "$VENDOR" \
            --maintainer "$MAINTAINER" \
            --url "$HOMEPAGE" \
            --description "$DESC" \
            --category "devel" \
            --architecture "$ARCH" \
            $DEPENDS_OPTS || echo "Pacman package build failed"

        mv *.deb *.rpm *.apk *.pkg.tar.* dist/ 2>/dev/null || true
      shell: bash

    - name: Package macOS
      if: runner.os == 'macOS'
      run: |
        mkdir -p dist

        # Detect architecture
        ARCH=$(uname -m)
        echo "Building for macOS architecture: $ARCH"

        # Create proper macOS package structure
        PKG_ROOT="pkgroot"
        mkdir -p "$PKG_ROOT/${{ inputs.prefix }}"
        
        # Copy installed files to package root
        cp -R stage/* "$PKG_ROOT/${{ inputs.prefix }}/" 2>/dev/null || true

        # Create component property list file
        cat > Distribution.xml << EOF
        <?xml version="1.0" encoding="utf-8"?>
        <installer-script minSpecVersion="1.000000">
            <title>${{ inputs.name }}-${{ env.VERSION }}</title>
            <organization>com.${{ github.repository_owner }}</organization>
            <domains enable_anywhere="false" enable_currentUserHome="false" enable_localSystem="true"/>
            <options customize="never" require-scripts="false"/>
            <pkg-ref id="com.${{ github.repository_owner }}.${{ inputs.name }}"/>
            <choices-outline>
                <line choice="default">
                    <line choice="com.${{ github.repository_owner }}.${{ inputs.name }}"/>
                </line>
            </choices-outline>
            <choice id="default"/>
            <choice id="com.${{ github.repository_owner }}.${{ inputs.name }}" visible="false">
                <pkg-ref id="com.${{ github.repository_owner }}.${{ inputs.name }}"/>
            </choice>
            <pkg-ref id="com.${{ github.repository_owner }}.${{ inputs.name }}" version="${{ env.VERSION }}" onConclusion="none">${{ inputs.name }}-${{ env.VERSION }}-$ARCH.pkg</pkg-ref>
        </installer-script>
        EOF

        # Create package using pkgbuild and productbuild
        pkgbuild --root "$PKG_ROOT" \
                 --identifier "com.${{ github.repository_owner }}.${{ inputs.name }}" \
                 --version "${{ env.VERSION }}" \
                 --install-location "${{ inputs.prefix }}" \
                 "${{ inputs.name }}-${{ env.VERSION }}-$ARCH.pkg"

        # Also create a tarball for direct installation
        tar czf "${{ inputs.name }}-${{ env.VERSION }}-macos-$ARCH.tar.gz" -C stage .

        # Move all artifacts to dist
        mv *.pkg *.tar.gz dist/

        echo "macOS packaging complete. Contents:"
        ls -la dist/
      shell: bash

    - name: Package Windows
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        mkdir dist
        Compress-Archive -Path stage\* -DestinationPath dist\${{ inputs.name }}-${{ env.VERSION }}-win.zip

    - name: Generate checksums
      run: |
        cd dist
        find . -type f -name "*" | xargs shasum -a 256 > SHA256SUMS
        echo "Generated checksums:"
        cat SHA256SUMS
      shell: bash

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.name }}-${{ runner.os }}
        path: dist/*
