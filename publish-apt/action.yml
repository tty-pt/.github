name: 'publish'
description: 'Publish .deb packages to an APT repo served from OpenBSD'
author: 'tty-pt'

inputs:
  source:
    description: 'Glob for .deb files to publish (e.g. dist/*.deb)'
    required: true
  host:
    description: 'Server hostname'
    required: true
  user:
    description: 'Server user'
    required: true
  ssh_key:
    description: 'Private SSH key'
    required: true
  gpg_key:
    description: 'Private GPG key (ASCII-armored)'
    required: false
    default: ""
  gpg_keyid:
    description: 'Key ID or fingerprint to use when signing'
    required: false
  gpg_pass:
    description: 'Passphrase for the GPG key (if any)'
    required: false

runs:
  using: 'composite'
  steps:
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ inputs.ssh_key }}" > ~/.ssh/id_ed25519
        chmod 600 ~/.ssh/id_ed25519
        ssh-keyscan -H ${{ inputs.host }} >> ~/.ssh/known_hosts
      shell: bash

    - name: Install apt-ftparchive
      run: |
        sudo apt-get update
        sudo rm -f /var/lib/man-db/auto-update
        sudo apt-get install -y apt-utils dpkg-dev rsync gnupg
      shell: bash

    - name: Fetch current repo from server
      run: |
        mkdir -p apt-repo
        rsync -avz -e "ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no" \
          ${{ inputs.user }}@${{ inputs.host }}:/var/www/htdocs/apt/ apt-repo/ || true
      shell: bash

    - name: Merge new packages
      run: |
        mkdir -p apt-repo/pool/main
        for deb in ${{ inputs.source }}; do
          if [ -f "$deb" ] && [[ "$deb" == *.deb ]]; then
            pkg=$(dpkg-deb -f "$deb" Package)
            ver=$(dpkg-deb -f "$deb" Version)
            arch=$(dpkg-deb -f "$deb" Architecture)
            firstletter=$(echo "$pkg" | cut -c1 | tr '[:upper:]' '[:lower:]')
            target="apt-repo/pool/main/$firstletter/$pkg"
            mkdir -p "$target"
            cp "$deb" "$target/${pkg}_${ver}_${arch}.deb"
          fi
        done
      shell: bash

    - name: Generate indexes
      run: |
        ORIGIN="${GITHUB_REPOSITORY_OWNER}"
        mkdir -p apt-repo/dists/stable/main/binary-amd64

        cat > apt-ftparchive.conf <<EOF
        Dir {
          ArchiveDir "apt-repo";
          CacheDir   "apt-repo/.cache";
        };
        Default {
          Packages::Compress ". gzip bzip2 xz";
          Sources::Compress  ". gzip bzip2 xz";
          Contents::Compress ". gzip bzip2 xz";
        };
        TreeDefault {
          Directory  "pool/main";
          Packages   "dists/stable/main/binary-amd64/Packages";
          Contents   "dists/stable/main/Contents-amd64";
        };
        BinDirectory "pool/main" {
          Packages "dists/stable/main/binary-amd64/Packages";
          Contents "dists/stable/main/Contents-amd64";
          Architectures "amd64";
          Section "main";
        };
        APT::FTPArchive::Release {
          Origin "$ORIGIN";
          Label "$ORIGIN";
          Suite "stable";
          Codename "stable";
          Components "main";
          Architectures "amd64";
          Acquire-By-Hash "yes";
          Description "APT repository for $ORIGIN";
        };
        EOF

        apt-ftparchive generate apt-ftparchive.conf
        gzip -kf apt-repo/dists/stable/main/binary-amd64/Packages
        apt-ftparchive -c apt-ftparchive.conf release apt-repo/dists/stable > apt-repo/dists/stable/Release
      shell: bash

    - name: Import GPG key
      if: ${{ inputs.gpg_key != '' }}
      run: |
        echo "${{ inputs.gpg_key }}" | gpg --batch --import
        echo "${{ inputs.gpg_keyid }}"
        gpg --list-secret-keys --keyid-format=long
      shell: bash

    - name: Export and distribute GPG public key
      if: ${{ inputs.gpg_key != '' }}
      run: |
        # Export the public key
        gpg --export --armor "${{ inputs.gpg_keyid }}" > apt-repo/archive-key.gpg

        # Also create a keyring file in the keyrings directory (modern apt approach)
        mkdir -p apt-repo/keyrings
        gpg --export --armor "${{ inputs.gpg_keyid }}" > apt-repo/keyrings/archive-key.gpg
      shell: bash

    - name: Sign Release
      if: ${{ inputs.gpg_key != '' }}
      run: |
        set -euo pipefail
        key="${{ inputs.gpg_keyid }}"

        # Sanity: make sure Release exists and isn't empty
        test -s apt-repo/dists/stable/Release

        # Sign inline
        gpg --batch --yes --local-user "$key" \
            --pinentry-mode loopback --passphrase "${{ inputs.gpg_pass }}" \
            --digest-algo SHA256 \
            --clearsign -o apt-repo/dists/stable/InRelease apt-repo/dists/stable/Release

        # Detached signature
        gpg --batch --yes --local-user "$key" \
            --pinentry-mode loopback --passphrase "${{ inputs.gpg_pass }}" \
            --digest-algo SHA256 \
            -abs -o apt-repo/dists/stable/Release.gpg apt-repo/dists/stable/Release

        # Verify the signatures were created
        echo "=== Verifying signatures ==="
        test -s apt-repo/dists/stable/InRelease
        test -s apt-repo/dists/stable/Release.gpg
        echo "✓ Signatures created successfully"

        # Verify we can verify with the public key
        gpg --verify apt-repo/dists/stable/Release.gpg apt-repo/dists/stable/Release
        echo "✓ Signature verification successful"

      shell: bash

    - name: Push repo back to server
      run: |
        rsync -avz -e "ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no" apt-repo/ \
          ${{ inputs.user }}@${{ inputs.host }}:/var/www/htdocs/apt/
      shell: bash
